## 前端优化

### 图片优化

> 原则：结合业务场景选择正确的图片格式；在图片不失真的情况下，图片大小达到最小；使用cdn进行引入。

> 工具：推荐[tinypng](https://tinypng.com/)图片压缩工具；[编码BASE64](https://tool.css-js.com/base64.html)的转换工具。

#### 1. JPEG/JPG

**有损压缩、体积小、加载快、不支持透明**

适合呈现色彩丰富而且尺寸大的图片。不能过分压缩，会显示出毛边。

#### 2. WEPB

**年轻的全能型**

WebP格式，图片的体积能够压缩到JPEG/JPG的2/3，能节省大量的服务器带宽资源和数据空间。在移动端上面使用比较合理，但是这是谷歌开发的图片格式。目前支持的情况：android原生和chrome浏览器支持WebP，iOS原生和safari浏览器尚不支持WebP。其他浏览器方面，除了opera外，都还不支持。业务量和并发量不大的情况下，还是别用这种格式，节省成本的操作另说了～

#### 3. PNG

**无损压缩、质量高、体积大、支持透明**

这里有PNG-8和PNG-24，两者可以说在显示色彩丰富度上面差别大，PNG-8可以显示2^8种颜色,而PNG-24可以显示2^24种颜色。PNG可以处理好线条间的关系，避免毛边，支持透明，但是体积大。根据色彩和应用场景的需求合理采用PNG-8或PNG-24。

#### 4. SVG

**文本文件、体积小、不失真、兼容性好**

svg从**1999年**被w3c列入开放标准，它的优点正如其名`可伸缩矢量图形`，能够在缩放的情况下不失真。而且，兼容性好，和性能关系最密切的一点就是：SVG 与 PNG 和 JPG 相比，文件体积更小，可压缩性更强。但是其学习成本高，可见[W3school的svg教程](http://www.w3school.com.cn/svg/index.asp)，还有其渲染成本比较高。

#### 5. BASE64

**文本文件，依赖编码、小图标解决方案**

图片转换成Base64后，会增加其体积的3/4左右，在处理小图标的时候比较理想，可以这么理解为下载图标的速度快过http的响应速度。一般是2kb左右的图标使用这种比较理想，大图就不建议使用了。[编码BASE64](https://tool.css-js.com/base64.html)可以轻松帮我们实现转换。

#### 6. GIF

**可动图，无损压缩、支持透明**

前端页面中使用到动画图片的情况下，我们第一想法就是使用gif图片来实现。但是如果不是循环播放的图片的话，关键帧@keyframe会更加适合。

目前，前端领域用到的图片格式上面的居多，其他图片格式感兴趣可以戳[传送门](https://baike.baidu.com/item/%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F/381122?fr=aladdin)

#### 补充

在减少http请求的场景下，`精灵图`也是一个很好的选择，也是针对像BASE64那样的小图标，不过看你的使用场景。个人比较偏向`BASE64`处理，因为在现代飞速发展的时代，移动设备普及，5g都将横行了，带来的些许大小差距是可以忽略不计的。而`BASE64`能更好的把握开发节奏~


### 缓存

浏览器缓存机制有四个方面，他们按照获取资源时请求的优先级依次排列如下：

1. Memory Cache
2. Service Worker Cache
3. HTTP Cache
4. Push Cache (HTTP2的新特性)

### MemoryCache

MemoryCache，是指存在内存中的缓存。从优先级上来说，它是浏览器最先尝试去命中的一种缓存。从效率上来说，它是响应速度最快的一种缓存。

根据掘金上**修言前辈**的总结可以知道：资源存不存在内存，浏览器秉承的是`节约原则`。我们发现，BASE64格式的图片，几乎永远可以被塞进memory cache，这可以视为浏览器为了节省渲染开销的“自保行为”；此外，体积不大的`JS、CSS`文件，也有较大地被写入内存的几率--相比之下，较大的`JS、CSS`文件就没有这个待遇了，内存是有限的，他们往往被直接摔进磁盘。

### Service Worker Cache

Service Worker 是一种独立于主线程之外的Javascript线程。它脱离于浏览器窗体，因此无法访问DOM。这样独立的个性使得Service Worker的“个人行为”无法干扰页面的性能，这个`幕后工作者`可以帮我们实现离线缓存，消息推送和网络代理等功能。借助Service Worker实现的离线缓存就称为**Service Worker Cache**。

Service Worker 的生命周期包括install、active、working三个阶段。一旦Service Worker 被install，它将始终存在，只会在active与working之间切换，除非我们主动终止它。这是可以用来实现离线存储的重要先决条件。


###  Http Cache

HTTP缓存分为**强缓存和协商缓存**。优先级较高的是强缓存，在命中强缓存失败的情况下，才会走协商缓存。

- **强缓存**

**强缓存**是利用http头中的`Expires和Cache-Control`两个字段来控制的。强缓存中，当请求再次发出时，浏览器会根据其中的`expire和cache-control`判断目标资源是否“命中”强缓存，若命中则直接从缓存中获取资源，**不会再与服务端发生通信**。

**强缓存的实现: 从expires到cache-control**

之前实现强缓存，过去我们都是使用`expires`。当服务器返回响应时，在`Response Headers`中将过期时间写入expires字段。比如下面：

```javascript
expires: Wed, 11 Sep 2019 16:12:18 GMT
```

expires是一个时间戳。如果我们试图再次向服务器请求资源，浏览器会先对比本地时间和expires的时间戳，如果本地时间小于expires设定的过期时间，那么就直接去缓存中取这个资源。

不过,expires是有问题的，它的最大问题在于对`本地时间`的依赖。如果服务端和客户端的时间设置可能不同，或者我直接手动去把客户端的时间改掉，那么expires将无法达到我们的预期。

HTTP1.1新增的`Cache-Control`字段能够避免上面expires带来的局限性。`cache-control`可以视为`expires`的完全替代方案。在当前的前端实践中，我们继续使用expires的唯一目的就是向下兼容。

```javascript
cache-control: max-age=31536000
```
上面中，`Cache-control`中，我们是通过**max-age**来控制资源的有效期。max-age不是一个时间戳，而是一个时间长度。以秒为单位。

`Cache-Control`相对于`expires`更加准确，它的优先级也更高。当`Cache-Control`与`expires`同时出现时，要以`Cache-Control`为准。

- **协商缓存：浏览器与服务器合作之下的缓存策略**

协商缓存依赖于服务端与浏览器之间的通信。

协商缓存机制下，浏览器需要向服务器去询问缓存的相关信息，进而判断是重新发起请求，下载完整的响应，还是从本地获取缓存的资源。

如果服务器提示缓存资源未改动（Not Modified），资源会被重定向到浏览器缓存，**这种情况下网络请求对应的状态是304**。

**协商缓存的实现:从Last-Modified到Etag**

`Last-Modified`是一个时间戳，如果我们启动了协商缓存，它会首次请求时随着Response Headers返回,如下：

```bash
Last-Modified: Fri, 27 Oct 2017 06:35:57 GMT
```

随后我们每次请求时，会带上一个叫`If-Modified-Since`的时间戳字段，它的值正是上一次response返回给它的`last-modified`值：

```bash
If-Modified-Since: Fri, 27 Oct 2017 06:35:57 GMT
```

服务器收到这个时间戳后，会比对该时间戳和资源在服务器上的最后修改时间是否是一致，从而判断资源是否发生了变化。如果发生了变化，就会返回一个完整的响应内容，并在`Response Headers`中添加新的`Last-Modified`值；否者返回304响应，`Response Headers`不会再添加`Last-Modified`字段。

> 有待补充...

### 参考

- 《前端性能优化原理与实践》 修言
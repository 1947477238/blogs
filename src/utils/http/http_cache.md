## http缓存

### 强制缓存

对于强制缓存，服务器响应的header中会用两个字段来表明 -- Expires和Cache-Control。

#### Expire

`Expires`的值为服务端返回的数据到期时间。当再次请求时的请求时间小于返回的此时间，则直接使用缓存数据。但由于服务端时间和客户端时间可能有误差，这也将导致缓存命中的误差，另一方面，`Expire`是HTTP1.0的产物，故现在大多数使用`Cache-Control`替代。

#### Cache-Control

`Cache-Control`有很多属性，不同的属性代表的意义也不同。

- `private`：客户端可以缓存
- `public`：客户端和代理服务器可以缓存
- `max-age=t`：缓存内容将在t秒后失效
- `no-cache`：需要使用协商缓存来验证缓存数据
- `no-store`：所有内容都不会缓存

### 协商缓存

协商缓存需要进行对比判断可以使用缓存。浏览器第一次请求数据时，服务器将缓存标识与数据一起响应给客户端，客户端将它们备份至缓存中。再次请求时，客户端会将缓存中的标识发送给服务器，服务器根据此标识判断。若未失效，返回304状态码，浏览器拿到此状态码就可以直接使用缓存数据了。对于协商缓存来说，缓存标识我们需要重新理解以下，下面我们将介绍下：

#### Last-Modified

Last-Modified：服务器在响应请求时，会告诉浏览器资源的最后修改时间。

If-Modified-Since：浏览器再次请求服务器的时候，请求头会包含此字段，后面跟着在缓存中获得的最后修改时间。服务端收到此请求头发现有`If-Modified-Since`，则与被请求资源的最后修改时间进行对比，如果一致则返回304和响应报文头，浏览器只需要从缓存中获取信息即可。从字面上看，就是说：从某个时间节点算起，是否是文件被修改了

#### Etag

`Etag`：服务器响应请求时，通过此字段告诉浏览器当前资源在服务器生成唯一的标识（生成规则由服务器决定）

`If-None-Match`: 再次请求服务器时，浏览器的请求报文头会包含此字段，后面的值为在缓存中获取的标识。服务器接收到此报文后发现`If-None-Match`则与被请求资源的唯一标识进行对比。

实际的应用中，由于Etag的计算是算法得出的，而算法会占用服务端计算的资源，所有服务端的资源都是宝贵的，所以很少用Etag了。

### 缓存的优点

1. 减少了冗余的数据传递，节省宽带流量
2. 减少了服务器的负担，大大提升了网站性能
3. 加快了客户端加载网页的速度，这也正是HTTP缓存属于客户端的原因

### 不同刷新的请求执行过程

1. 浏览器地址中写入URL，回车。浏览器发现缓存中有这个文件了，不用继续请求了，直接请缓存拿。（最快）
2. F5 F5就是告诉浏览器，别偷懒，好歹去服务器看看这个文件是否过期了。于是浏览器就胆胆襟襟的发送一个请求带上`If-Modify-Since`。
3. Ctrl+F5 告诉浏览器，你先把缓存中的这个文件给我删了，然后再去服务器请求个完整的资源文件下来。于是客户端就完成了强行更新的操作。



### 参考

来源：https://juejin.im/post/5a1d4e546fb9a0450f21af23
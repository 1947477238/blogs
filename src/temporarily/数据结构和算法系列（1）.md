## 数据结构和算法系列（上）

这个系列文章分为上下两章，使用的是javascript语言进行辅助，毕竟自己是前端切图仔。第一章讲的是基本的数据结构--对相关的数据项进行组织的特殊架构。

> 这里需要补充数据结构的定义

讲到数据结构，我们都会谈到线性结构和非线性结构。

**1.线性结构**是一个有序数据元素的集合。它应该满足下面的特征：

- 集合中必存在唯一的一个“第一个元素”
- 集合中必存在唯一的一个“最后的元素”
- 除最后一元素之外，其它数据元素均有唯一的“后继”
- 除第一个元素之外，其它数据元素均有唯一的“前驱”

按照百度百科的定义，我们知道符合条件的数据结构就有栈、队列和其它。

**2.非线性结构**其逻辑特征是一个节点元素可以有很多个直接前驱和多个直接后继。

那么，符合条件的数据结构就有图、树和其它。

嗯～了解一下就行。我们进入正题：

### 数组

数组是一种线性结构，以十二生肖（鼠、牛、虎、兔、龙、蛇、马、羊、猴、鸡、狗、猪）排序为例：

![array_demo](https://img-fe.ggwan.com/images/9aa57ef9ad250b-1750x162.png)

我们创建一个数组并打印出结果就一目了然了：

```javascript
let arr = ['鼠', '牛', '虎', '兔', '龙', '蛇', '马', '羊', '猴', '鸡', '狗', '猪'];
arr.forEach((item, index) => {
	console.log(`[ ${index} ] => ${item}`);
});

# [ 0 ] => 鼠
# [ 1 ] => 牛
# [ 2 ] => 虎
# [ 3 ] => 兔
# [ 4 ] => 龙
# [ 5 ] => 蛇
# [ 6 ] => 马
# [ 7 ] => 羊
# [ 8 ] => 猴
# [ 9 ] => 鸡
# [ 10 ] => 狗
# [ 11 ] => 猪
```

我们可以在数组的任意位置插入和删除数据，常用的属性和一些方法如下，直接调用相关的方法就可以实现。这里不做演示～

**常用的属性**

- length : 表示数组的长度

**常用的方法**

- splice(index, howmany, item, ... itemx)

	**splice()**方法是数组中最强大的方法。可以实现数组元素的添加、删除和替换。`index`参数为整数且必需，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置；`howmany`参数为必需，要删除的项目数量，如果设置为 0，则不会删除项目；`item1, ... itemx`为可选，向数组添加新的项目。
	
- indexOf(searchValue, fromIndex)

	**indexOf()**方法返回某个指定字符串值在数组中的位置。`searchValue`是查询的字符串；`fromIndex`是查询的开始位置，默认是0。如果查询不到，会返回-1。
	
- concat(array1, ... arrayn)

	**concat()**方法用于连接两个或者多个数组。
	
- push(newElement1, ... newElementN)

	**push()**方法可向`数组的末尾`添加一个或者多个元素。
	
- unshift(newElement1, ... newElementN)

	**unshift()**方法可向`数组的开头`添加一个或者多个元素。
	
- pop()

	**pop()**方法用于删除并返回`数组的最后一个元素`。
	
- shift()

	**shift()**方法可以删除数组的`第一个元素`。
	
- reverse()

	**reverse()**方法用于数组的反转
	
- sort(sortFn)

	**sort()**方法是对数组的元素排序。参数`sortFn`可选，其规定排序顺序，必须是函数。
	
```javascript
let values = [0, 1, 5, 10, 15];
values.sort();
console.log(values); // [0, 1, 10, 15, 5]
// 为什么会出现这种排序结果呢❓
// 因为在忽略sortFn的情况下，元素会按照转换为的字符串的各个字符的Unicode位点进行排序如下
let equalValues = ['0', '1', '5', '10', '15'];
equalValues.sort();
console.log(equalValues); //  ["0", "1", "10", "15", "5"]

let arr = [0, 10, 5, 1, 15];
function compare(el1, el2){
    return el1 - el2; // 升序排列
}
arr.sort(compare);
console.log(arr); // [0, 1, 5, 10, 15]

arr.sort((el1, el2) => {
    return el2 - el1; // 降序排列
}); 
console.log(arr); // [15, 10, 5, 1, 0]
```

- forEach(fn(currentValue, index, arr), thisValue)

	**forEach()**方法用于调用数组的每个元素，并将元素传递给回调函数。参数`function(currentValue, index, arr){}`是一个回调函数。`thisValue`可选，传递给函数的值一般用 "this" 值，如果这个参数为空， "undefined" 会传递给 "this" 值。

- every(fn(currentValue, index, arr), thisValue)

	**every()**方法用于检测数组中所有元素是否符合指定条件，如果数组中检测到有一个元素不满足，则整个表达式返回`false`，且剩余的元素不再检查。如果所有的元素都满足条件，则返回`true`。
	
- some(fn(currentValue,index,arr),thisValue)

	**some()**方法用于检测数组中元素是否满足指定条件。只有有一个符合就返回`true`，剩余的元素不再检查。如果所有元素都不符合条件，则返回`false`。
	
- reduce(fn(accumulator, currentValue, currentIndex, arr), initialValue)

	**reduce()**方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终为一个值。回调函数的四个参数的意义如下：`accumulator`，必需，累计器累计回调的返回值, 它是上一次调用回调时返回的累积值，或initialValue；`currentValue`，必需，数组中正在处理的元素；`currentIndex`,可选,数组中正在处理的当前元素的索引，如果提供了initialValue，则起始索引号为0，否则为1;`arr`,可选,当前元素所属的数组对象。`initialValue`，可选，传递给函数的初始值。
	
```javascript
let arr = [1, 2, 3, 4];
let reducer = (accumulator, currentValue) => accumulator + currentValue;

// 1 + 2 + 3 + 4
console.log(arr.reduce(reducer)); // 10

// 5 + 1 + 2 + 3 + 4
console.log(arr.reduce(reducer, 5)); // 15
```

### 栈

**栈**是一种后进先出(LIFO)线性表，是一种基于数组的数据结构。（ps：其实后面讲到数据结构的或多或少和数组有些影子）

- LIFO(last in first out)表示后进入的元素，第一个弹出栈空间。类似于自动餐托盘，最后放上去的托盘，往往先被拿出来使用。
- 仅允许在表的一端进行插入和移除元素。这一端被称为**栈顶**，相对地，把另一端称为**栈底**。如下图的标识。
- 向一个栈插入新元素称作**进栈、入栈或压栈**，它是将新元素放在栈顶元素上面，使之成为新的栈顶元素。
- 从一个栈删除元素又称为**出栈或退栈**，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。

![stack_demo](https://img-fe.ggwan.com/images/3dc3756c0fa060-1550x508.png)

我们实际上写一下，熟悉一下栈：

```typescript
class Stack {
    constructor(){
        this.items = [];
    }
    // 入栈操作
    push(element = ''){
        if(!element) return;
        this.items.push(element);
        return this;
    }
    // 出栈操作
    pop(){
        this.items.pop();
        return this;
    }
    // 对栈一瞥，理论上只能看到栈顶或者说即将处理的元素
    peek(){
        return this.items[this.size() - 1];
    }
    // 打印栈数据
    print(){
        return this.items.join(' ');
    }
    // 栈是否为空
    isEmpty(){
        return this.items.length == 0;
    }
    // 返回栈的元素个数
    size(){
        return this.items.length;
    }
}
let stack = new Stack(),
    arr = ['鼠', '牛', '虎', '兔', '龙', '蛇', '马', '羊', '猴', '鸡', '狗', '猪'];
arr.forEach(item => {
    stack.push(item);
});
console.log(stack.print()); // 鼠 牛 虎 兔 龙 蛇 马 羊 猴 鸡 狗 猪
console.log(stack.peek()); // 猪
stack.pop().pop().pop().pop();
console.log(stack.print()); // 鼠 牛 虎 兔 龙 蛇 马 羊
console.log(stack.isEmpty()); // false
console.log(stack.size()); // 8
```

⚠️ 注意：我们栈这里的push和pop要和数组方法的push和pop方法区分下。

说到**栈**，这也让我想到了翻译的一篇文章[JS的执行上下文和环境栈是什么?](https://juejin.im/post/5c855410e51d45555e2626fd)，感兴趣的话可以戳进去看下。

### 队列

**队列**是一种先进先出（FIFO）的受限的线性表。受限体现在允许在表的前端（front）进行操作删除，在表的末尾（rear）进行插入【优先队列这些排除在外】。

![queue_demo](https://img-fe.ggwan.com/images/6039d1be3622f5-1606x512.png)

代码走一遍：

```typescript
// 队列
class Queue {
    constructor(){
        this.items = [];
    }
    // 入队操作
    enqueue(element = ''){
        if(!element) return;
        this.items.push(element);
        return this;
    }
    // 出队操作
    dequeue(){
        this.items.shift();
        return this;
    }
    // 查看队前元素或者说即将处理的元素
    front(){
        return this.items[0];
    }
    // 查看队列是否为空
    isEmpty(){
        return this.items.length == 0;
    }
    // 查看队列的长度
    len(){
        return this.items.length;
    }
    // 打印队列数据
    print(){
        return this.items.join(' ');
    }
}

let queue = new Queue(),
    arr = ['鼠', '牛', '虎', '兔', '龙', '蛇', '马', '羊', '猴', '鸡', '狗', '猪'];
arr.forEach(item => {
    queue.enqueue(item);
});
console.log(queue.print()); // 鼠 牛 虎 兔 龙 蛇 马 羊 猴 鸡 狗 猪
console.log(queue.isEmpty()); // false
console.log(queue.len()); // 12
queue.dequeue().dequeue();
console.log(queue.front()); // 虎
console.log(queue.print()); // 虎 兔 龙 蛇 马 羊 猴 鸡 狗 猪
```

### 链表

在进入正题之前，我们先来聊聊数组的优缺点。

**优点：**

- 要存储多个元素，比较常用
- 访问便捷，使用[index]即可

**缺点：**

- 数组的创建通常需要申请一段连续的内存空间，并且大小是固定的（大多数的编程语言数组都是固定的），所以在进行扩容的时候难以掌控。（一般情况下，申请一个更大的数组，会是之前的倍数，比如两倍。然后，再将原数组中的元素复制过去）
- 插入数据越是靠前，其成本很高，因为需要进行大量元素的位移。

相对数组，链表亦可以存储多个元素，而且存储的元素在内容中不必是连续的空间；在插入和删除数据时，[时间复杂度](https://github.com/reng99/blogs/issues/5)可以达到O(1)。在查找的元素的时候，还是需要从头开始遍历的，比数组在知道下表的情况下要快，但是数组如果不确定下标的话，那就另说了...

![train](https://img-fe.ggwan.com/images/4fab9eb1353414-1024x295.png)

上面的火车图已经很形象的表示了普通链表的结构，我们再来形象化一下：

![linklist_demo](https://img-fe.ggwan.com/images/76b0f37047ddcb-1746x880.png)

**链表**是由一组节点组成的集合。每个节点都使用一个对象的引用指向它的后继。如上图。下面用代码实现下：


```typescript
// 链表
class Node {
    constructor(element){
        this.element = element;
        this.next = null;
    }
}

class LinkedList {
    constructor(){
        this.length = 0; // 链表长度
        this.head = new Node('head'); // 表头节点
    }
    /**
     * @method find 查找元素的功能，找不到的情况下直接返回链尾节点
     * @param { String } item 要查找的元素
     * @return { Object } 返回查找到的节点 
     */
    find(item = ''){
        let currNode = this.head;
        while(currNode.element != item && currNode.next){
            currNode = currNode.next;
        }
        return currNode;
    }
    /**
    * @method findPrevious 查找链表指定元素的前一个节点
    * @param { String } item 指定的元素
    * @return { Object } 返回查找到的之前元素的前一个节点，找不到节点的话返回链尾节点
    */
    findPrevious(item){
        let currNode = this.head;
        while((currNode.next != null) && (currNode.next.element != item)){
            currNode = currNode.next;
        }
        return currNode;
    }
    /**
     * @method insert 插入功能
     * @param { String } newElement 要出入的元素
     * @param { String } item 想要追加在后的元素（此元素不一定存在）
     */
    insert(newElement = '', item){
        if(!newElement) return;
        let newNode = new Node(newElement),
            currNode = this.find(item);
        newNode.next = currNode.next;
        currNode.next = newNode;
        this.length++;
        return this;
    }
    // 展示链表元素
    display(){
        let currNode = this.head,
            arr = [];
        while(currNode.next != null){
            arr.push(currNode.next.element);
            currNode = currNode.next;
        }
        return arr.join(' ');
    }
    // 链表的长度
    size(){
        return this.length;
    }
    // 查看链表是否为空
    isEmpty(){
        return this.length == 0;
    }
    /**
     * @method indexOf 查看链表中元素的索引
     * @param { String } element 要查找的元素
     */
    indexOf(element){
        let currNode = this.head,
            index = 0;
        while(currNode.next != null){
            index++;
            if(currNode.next.element == element){
                return index;
            }
            currNode = currNode.next;
        }
        return -1;
    }
    /**
     * @method removeEl 移除指定的元素
     * @param { String } element 
     */
    removeEl(element){
        let preNode = this.findPrevious(element);
        preNode.next = preNode.next != null ? preNode.next.next : null;
    }
}

let linkedlist = new LinkedList();
console.log(linkedlist.isEmpty()); // true
linkedlist.insert('鼠').insert('虎').insert('牛', '鼠');
console.log(linkedlist.display()); // 鼠 牛 虎
console.log(linkedlist.find('猪')); // Node { element: '虎', next: null }
console.log(linkedlist.find('鼠')); // Node { element: '鼠', next: Node { element: '牛', next: Node { element: '虎', next: null } } }
console.log(linkedlist.size()); // 3
console.log(linkedlist.indexOf('鼠')); // 1
console.log(linkedlist.indexOf('猪')); // -1
console.log(linkedlist.findPrevious('虎')); // Node { element: '牛', next: Node { element: '虎', next: null } }
linkedlist.removeEl('鼠');
console.log(linkedlist.display()); // 牛 虎
```

### 字典

**字典**的主要特点是键值一一对应的关系。可以比喻成我们学习中查不同语言翻译的`字典`。这里字典的键（key）理论上是可以使用任意的内容，但是还是建议语意化一点，比如下面的十二生肖图：

![dictionary_demo](https://img-fe.ggwan.com/images/4be75387a07a8c-946x1160.png)

```typescript
class Dictionary {
    constructor(){
        this.items = {};
    }
    /**
     * @method set 设置字典的键值对
     * @param { String } key 键
     * @param {*} value 值
     */
    set(key = '', value = ''){
        this.items[key] = value;
        return this;
    }
    /**
     * @method get 获取某个值
     * @param { String } key 键
     */
    get(key = ''){
        return this.has(key) ? this.items[key] : undefined;
    }
    /**
     * @method has 判断是否含有某个键的值
     * @param { String } key 键
     */
    has(key = ''){
        return this.items.hasOwnProperty(key);
    }
    /**
     * @method remove 移除元素
     * @param { String } key 
     */
    remove(key){
        if(!this.has(key))  return false;
        delete this.items[key];
        return true;
    }
    // 展示字典的键
    keys(){
        return Object.keys(this.items).join(' ');
    }
    // 字典的大小
    size(){
        return Object.keys(this.items).length;
    }
    // 展示字典的值
    values(){
        return Object.values(this.items).join(' ');
    }
    // 清空字典
    clear(){
        this.items = {};
        return this;
    }
}

let dictionary = new Dictionary(),
    arr = ['鼠', '牛', '虎', '兔', '龙', '蛇', '马', '羊', '猴', '鸡', '狗', '猪'];
    arr.forEach((item, index) => {
        dictionary.set('第'+(++index)+'生肖', item);
    });
console.log(dictionary.keys()); // 第1生肖 第2生肖 第3生肖 第4生肖 第5生肖 第6生肖 第7生肖 第8生肖 第9生肖 第10生肖 第11生肖 第12生肖
console.log(dictionary.values()); // 鼠 牛 虎 兔 龙 蛇 马 羊 猴 鸡 狗 猪
console.log(dictionary.has('第5生肖')); // true
console.log(dictionary.get('第3生肖')); // 虎
console.log(dictionary.remove('第12生肖')); // true
console.log(dictionary.size()); // 11
console.log(dictionary.clear().size()); // 0
```

### 集合

**集合**通常是由一组无序的，不能重复的元素构成。 一些常见的集合操作如图：

![set_demo](https://img-fe.ggwan.com/images/8f86a8fe9eff72-1848x1314.png)

es6中已经封装好了可用的[Set类](http://es6.ruanyifeng.com/#docs/set-map)。

```typescript
// 集合
class Set {
    constructor(){
        this.items = [];
    }
    /**
     * @method add 添加元素
     * @param { String } element 
     * @return { Boolean }
     */
    add(element = ''){
        if(this.items.indexOf(element) >= 0) return false;
        this.items.push(element);
        return true;
    }
    // 集合的大小
    size(){
        return this.items.length;
    }
    // 集合是否包含某指定元素
    has(element = ''){
        return this.items.indexOf(element) >= 0;
    }
    // 展示集合
    show(){
        return this.items.join(' ');
    }
    // 移除某个元素
    remove(element){
        let pos = this.items.indexOf(element);
        if(pos < 0) return false;
        this.items.splice(pos, 1);
        return true;
    }
    /**
     * @method union 并集
     * @param { Array } set 数组集合
     * @return { Object } 返回并集的对象
     */
    union(set = []){
        let tempSet = new Set();
        for(let i = 0; i < this.items.length; i++){
            tempSet.add(this.items[i]);
        }
        for(let i = 0; i < set.items.length; i++){
            if(tempSet.has(set.items[i])) continue;
            tempSet.items.push(set.items[i]);
        }
        return tempSet;
    }
    /**
     * @method intersect 交集
     * @param { Array } set 数组集合
     * @return { Object } 返回交集的对象
     */
    intersect(set = []){
        let tempSet = new Set();
        for(let i = 0; i < this.items.length; i++){
            if(set.has(this.items[i])){
                tempSet.add(this.items[i]);
            }
        }
        return tempSet;
    }
    /**
     * @method isSubsetOf 【A】是【B】的子集❓
     * @param { Array } set 数组集合
     * @return { Boolean } 返回真假值
     */
    isSubsetOf(set = []){
        if(this.size() > set.size()) return false;
        this.items.forEach*(item => {
            if(!set.has(item)) return false;
        });
        return true;
    }
}

let set = new Set(),
    arr = ['鼠', '牛', '虎', '兔', '龙', '蛇', '马', '羊', '猴'];
arr.forEach(item => {
    set.add(item);
});
console.log(set.show()); // 鼠 牛 虎 兔 龙 蛇 马 羊 猴
console.log(set.has('猪')); // false
console.log(set.size()); // 9
set.remove('鼠');
console.log(set.show()); // 牛 虎 兔 龙 蛇 马 羊 猴
let setAnother = new Set(),
    anotherArr = ['马', '羊', '猴', '鸡', '狗', '猪'];
anotherArr.forEach(item => {
    setAnother.add(item);
});
console.log(set.union(setAnother).show()); // 牛 虎 兔 龙 蛇 马 羊 猴 鸡 狗 猪
console.log(set.intersect(setAnother).show()); // 马 羊 猴
console.log(set.isSubsetOf(setAnother)); // false
```

### 散列表/哈希表

散列是一种常用的存储技术，散列使用的数据结构叫做**散列表/哈希表**。在散列表上插入、删除和取用数据都非常快，但是对于查找操作来说却效率低下，比如查找一组数据中的最大值和最小值。查找的这些操作得求助其它数据结构，比如下面要讲的二叉树。

切入个案例感受下哈希表：

**假如一家公司有1000个员工, 现在我们需要将这些员工的信息使用某种数据结构来保存起来。你会采用什么数据结构呢？**

- 方案一：数组
	- 按照顺序将所有员工信息依次存入一个长度为1000的数组中。每个员工的信息都保存在数组的某个位置上。
	- 但是我们要查看某个具体员工的信息怎么办呢？一个个查找吗？不太好找。
	- 数组最大的优势是什么？通过下标值获取信息。
	- 所以为了可以通过数组快速定位到某个员工，最好给员工信息中添加一个员工编号，而`编号`对应的就是员工的`下标值`。
	- 当查找某个员工信息时，通过员工号可以快速定位到员工的信息位置。

- 方案二：链表
	- 链表对应插入和删除数据有一定的优势。
	- 但是对于获取员工的信息，每次都必须从头遍历到尾，这种方式显然不是特别适合我们这里。

- 最终方案：
	- 这么看最终方案似乎就是数组了，但是数组还是有缺点，什么缺点呢？
	- 假如我们想查看下张三这位员工的信息，但是我们不知道张三的员工编号，怎么办呢？
	- 当然，我们可以问他的员工编号。但是我们每查找一个员工都是要问一下这个员工的编号吗？不合适。【那我们还不如直接问他的信息嘞】
	- 能不能有一种办法，让张三的名字和他的员工编号产生直接的关系呢？
	- 也就是通过张三这个名字，我们就能获取到他的索引值，而再通过索引值我们就能获取张三的信息呢？
	- 这样的方案已经存在了，就是使用哈希函数，让某个key的信息和索引值对应起来。

那么散列表的原理和实现又是怎样的呢，我们来聊聊。

我们的哈希表是基于数组完成的，我们从数组这里切入解析下。`数组可以通过下标直接定位到相应的空间`，哈希表的做法就是这种类似的实现。哈希表就是把`key(键)`通过一个固定的算法函数（此函数称为哈希函数/散列函数）转换成一个整型数字，然后就将该数字对数组长度进行**取余**，取余结果就当作数组的下标，将`value(值)`存储在以该数字为下标的数组空间里，而当使用哈希表进行查询的时候，就是再次使用哈希函数将`key`转换为对应的数组下标，并定位到该空间获取`value`。

结合下面的代码，也许你会更容易理解：

```typescript
// 哈希表
class HashTable {
    constructor(){
        this.table = new Array(137);
    }
    /**
     * @method hashFn 哈希函数
     * @param { String } data 传入的字符串
     * @return { Number } 返回取余的数字
     */
    hashFn(data){
        let total = 0;
        for(let i = 0; i < data.length; i++){
            total += data.charCodeAt(i);
        }
        return total % this.table.length;
    }
    /**
     * 
     * @param { String } data 传入的字符串
     */
    put(data){
        let pos = this.hashFn(data);
        this.table[pos] = data;
        return this;
    }
    // 展示
    show(){
        this.table && this.table.forEach((item, index) => {
            if(item != undefined){
                console.log(index + ' => ' + item);
            }
        })
    }
    // ...获取值get函数等看官感兴趣的话自己补充测试啦
}

let hashtable = new HashTable(),
    arr = ['mouse', 'ox', 'tiger', 'rabbit', 'dragon', 'snake', 'horse', 'sheep', 'monkey', 'chicken', 'dog', 'pig'];
arr.forEach(item => {
    hashtable.put(item);
});
hashtable.show();
// 5 => mouse
// 40 => dog
// 46 => pig
// 80 => rabbit
// 87 => dragon
// 94 => ox
// 111 => monkey
// 119 => snake
// 122 => sheep
// 128 => tiger
// 134 => horse

// 那么问题来了，十二生肖里面的_小鸡_去哪里了呢❓
// 被_小萌狗_给覆盖了，因为其位置都是40（这个可以自己证明下）
// 问题又来了，那么应该如何解决这种被覆盖的冲突呢❓
```

![hashtable_demo](https://img-fe.ggwan.com/images/c9757fb537f3c3-1056x2122.png)

那么，我们存储数据的时候，产生冲突的时候我们可以像下面这样解决：

**1. 线性探测法**

当发生碰撞（冲突）时，线性探测法检查散列表中的下一个位置【有可能非顺序查找位置，不一定是下一个位置】是否为空。如果为空，就将数据存入该位置；如果不为空，则继续检查下一个位置，直到找到一个空的位置为止。该技术是基于一个事实：每个散列表都有很多空的单元格，可以使用它们存储数据。

**2. 开链法**

当发生碰撞时，我们任然希望将`key（键）`存储到通过哈希函数产生的索引位置上，那么我们可以使用**开链法**。**开链法**是指实现哈希表底层的数组中，每个数组元素又是一个新的数组结构，比如另一个数组（这样结合起来就是二位数组了），链表等，这样就能存储多个键了。使用这种技术，即使两个`key（键）`散列后的值相同，依然是被保存在同样的位置，只不过它们是被保存在另一个数据结构上而已。以另一个数据结构是数组为例，存储的数据如下：

![open_link_method](https://img-fe.ggwan.com/images/bd2373dd1028ce-1234x542.png)


### 二叉查找树

- 树的定义：

	- 树（Tree）：`n(n >= 0)`个节点构成的有限集合。
		- 当`n = 0`时，称为空树；
		- 对任意一棵空树`(n > 0)`，它具备以下性质：
		- 树中有一个称为**根(Root)**的特殊节点，用`r(root)`表示；
		- 其余节点可分为`m(m > 0)`个互不相交的有限集`T1,T2,...Tm`，其中每个集合本省又是一棵树，称为原来树的**子树（SubTree）**

	- 注意：
		- 子树之间`不可以相交`；
		- 除了根节点外，每个节点有且仅有一个父节点；
		- 一个`N`个节点的树有`N-1`条边。

- 树的术语：

	- 节点的度（Degree）：节点的子树个数。
	- 树的度：树的所有节点中最大的度数（树的度通常为节点个数的`N-1`）。
	- 叶节点（Leaf）：度为`0`的节点（也称叶子节点）。
	- 父节点（Parent）：有子树的节点是其子树的父节点。
	- 子节点（Child）：若`A`节点是`B`节点的父节点，则称`B`节点是`A`节点的子节点。
	- 兄弟节点（Sibling）：具有同一个父节点的各节点彼此是兄弟节点。
	- 路径和路径长度：从节点`n1`到`nk`的路径为一个节点序列`n1,n2,n3,...,nk`，`ni`是`ni+1`的父节点。路径所包含边的个数为路径长度。
	- 节点的层次（Level）：规定根节点在`第0层`，它的子节点是`第1层`，子节点的子节点是`第2层`，以此类推。
	- 树的深度（Depth）：树中所有节点中的最大层次是这棵树的深度（因为上面是从第0层开始，深度 = 第最大层数 + 1）

如下图：

![tree_intro](https://img-fe.ggwan.com/images/e98fe35827628a-1462x742.png)

- 二叉树的定义：

	- 二叉树可以为空，也就是没有节点
	- 二叉树若不为空，则它是由根节点和称为其左子树`TL`和右子树`RT`的两个不相交的二叉树组成
	- 二叉树每个节点的子节点不允许超过`两个`

- 二叉树的五种形态：

	- 空
	- 只有根节点
	- 只有左子树
	- 只有右子树
	- 左右子树均有

对应下图（从左至右）：

![five_style_binary_tree](https://img-fe.ggwan.com/images/d62b5b4649083b-1410x414.png)

我们接下来要讲的是**二叉查找树（BST，Binary Search Tree）**。**二叉查找树**，也称二叉搜索树或二叉排序树，是一种特殊的二叉树，相对值较`小`的值保存在`左`节点中，较`大`的值保存在`右`节点中。特殊的结构能够快速的进行查找、插入和删除数据。下面我们来实现下：

```typescript

```

### 图

> 有待补充

### 后话

> 文章中的一些案例来自coderwhy的数据结构和算法系列文章，感谢其授权
 
![author_wechat_permission](https://img-fe.ggwan.com/images/a3198fa0bca62f-1272x1008.png)
 
 > 文章首发
 
 > 更多内容 https://github.com/reng99/blogs
 
### 参考

- [coderwhy的数据结构和算法系列文章](https://www.jianshu.com/p/38853c044156)

- 《数据结构与算法JavaScript描述》


## 数据结构和算法系列（上）

这个系列文章分为上下两章，使用的是javascript语言进行辅助，毕竟自己是前端切图仔。第一章讲的是基本的数据结构--对相关的数据项进行组织的特殊架构。

讲到数据结构，我们都会谈到线性结构和非线性结构。

**1.线性结构**是一个有序数据元素的集合。它应该满足下面的特征：

- 集合中必存在唯一的一个“第一个元素”
- 集合中必存在唯一的一个“最后的元素”
- 除最后一元素之外，其它数据元素均有唯一的“后继”
- 除第一个元素之外，其它数据元素均有唯一的“前驱”

按照百度百科的定义，我们知道符合条件的数据结构就有栈、队列和其它。

**2.非线性结构**其逻辑特征是一个节点元素可以有很多个直接前驱和多个直接后继。

那么，符合条件的数据结构就有图、树和其它。

嗯～了解一下就行。我们进入正题：

### 数组

以十二生肖（鼠、牛、虎、兔、龙、蛇、马、羊、猴、鸡、狗、猪）排序为例：

![array_demo](https://img-fe.ggwan.com/images/d8779522d31c6d-2164x194.png)

我们创建一个数组并打印出结果就一目了然了：

```javascript
let arr = ['鼠', '牛', '虎', '兔', '龙', '蛇', '马', '羊', '猴', '鸡', '狗', '猪'];
arr.forEach((item, index) => {
	console.log(`[ ${index} ] => ${item}`);
});

# [ 0 ] => 鼠
# [ 1 ] => 牛
# [ 2 ] => 虎
# [ 3 ] => 兔
# [ 4 ] => 龙
# [ 5 ] => 蛇
# [ 6 ] => 马
# [ 7 ] => 羊
# [ 8 ] => 猴
# [ 9 ] => 鸡
# [ 10 ] => 狗
# [ 11 ] => 猪
```

**常用的属性**

- length : 表示数组的长度

**常用的方法**

- splice(index, howmany, item, ... itemx)

	**splice()**方法是数组中最强大的方法。可以实现数组元素的添加、删除和替换。`index`参数为整数且必需，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置；`howmany`参数为必需，要删除的项目数量，如果设置为 0，则不会删除项目；`item1, ... itemx`为可选，向数组添加新的项目。
	
- indexOf(searchValue, fromIndex)

	**indexOf()**方法返回某个指定字符串值在数组中的位置。`searchValue`是查询的字符串；`fromIndex`是查询的开始位置，默认是0。如果查询不到，会返回-1。
	
- concat(array1, ... arrayn)

	**concat()**方法用于连接两个或者多个数组。
	
- push(newElement1, ... newElementN)

	**push()**方法可向`数组的末尾`添加一个或者多个元素。
	
- unshift(newElement1, ... newElementN)

	**unshift()**方法可向`数组的开头`添加一个或者多个元素。
	
- pop()

	**pop()**方法用于删除并返回`数组的最后一个元素`。
	
- shift()

	**shift()**方法可以删除数组的`第一个元素`。
	
- reverse()

	**reverse()**方法用于数组的反转
	
- sort(sortFn)

	**sort()**方法是对数组的元素排序。参数`sortFn`可选，其规定排序顺序，必须是函数。
	
```javascript
let values = [0, 1, 5, 10, 15];
values.sort();
console.log(values); // [0, 1, 10, 15, 5]
// 为什么会出现这种排序结果呢❓
// 因为在忽略sortFn的情况下，元素会按照转换为的字符串的各个字符的Unicode位点进行排序如下
let equalValues = ['0', '1', '5', '10', '15'];
equalValues.sort();
console.log(equalValues); //  ["0", "1", "10", "15", "5"]

let arr = [0, 10, 5, 1, 15];
function compare(el1, el2){
    return el1 - el2; // 升序排列
}
arr.sort(compare);
console.log(arr); // [0, 1, 5, 10, 15]

arr.sort((el1, el2) => {
    return el2 - el1; // 降序排列
}); 
console.log(arr); // [15, 10, 5, 1, 0]
```

- forEach(fn(currentValue, index, arr), thisValue)

	**forEach()**方法用于调用数组的每个元素，并将元素传递给回调函数。参数`function(currentValue, index, arr){}`是一个回调函数。`thisValue`可选，传递给函数的值一般用 "this" 值，如果这个参数为空， "undefined" 会传递给 "this" 值。

- every(fn(currentValue, index, arr), thisValue)

	**every()**方法用于检测数组中所有元素是否符合指定条件，如果数组中检测到有一个元素不满足，则整个表达式返回`false`，且剩余的元素不再检查。如果所有的元素都满足条件，则返回`true`。
	
- some(fn(currentValue,index,arr),thisValue)

	**some()**方法用于检测数组中元素是否满足指定条件。只有有一个符合就返回`true`，剩余的元素不再检查。如果所有元素都不符合条件，则返回`false`。
	
- reduce(fn(accumulator, currentValue, currentIndex, arr), initialValue)

	**reduce()**方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终为一个值。回调函数的四个参数的意义如下：`accumulator`，必需，累计器累计回调的返回值, 它是上一次调用回调时返回的累积值，或initialValue；`currentValue`，必需，数组中正在处理的元素；`currentIndex`,可选,数组中正在处理的当前元素的索引，如果提供了initialValue，则起始索引号为0，否则为1;`arr`,可选,当前元素所属的数组对象。`initialValue`，可选，传递给函数的初始值。
	
```javascript
let arr = [1, 2, 3, 4];
let reducer = (accumulator, currentValue) => accumulator + currentValue;

// 1 + 2 + 3 + 4
console.log(arr.reduce(reducer)); // 10

// 5 + 1 + 2 + 3 + 4
console.log(arr.reduce(reducer, 5)); // 15
```

### 栈

> 栈是一种先进先出(FIFO)线性表，是一种基于数组的数据结构。（ps：其实后面讲到数据结构的或多或少和数组有些影子）

此处应该有栈相关的说明图img...

我们实际上写一下，熟悉一下栈：

```typescript
class Stack {
    constructor(){
        this.items = [];
    }
    // 入栈操作
    push(element = ''){
        if(!element) return;
        this.items.push(element);
        return this;
    }
    // 出栈操作
    pop(){
        this.items.pop();
        return this;
    }
    // 对栈一瞥，理论上只能看到栈顶或者说即将处理的元素
    peek(){
        return this.items[this.size() - 1];
    }
    // 打印栈数据
    print(){
        return this.items.join(' ');
    }
    // 栈是否为空
    isEmpty(){
        return this.items.length == 0;
    }
    // 返回栈的元素个数
    size(){
        return this.items.length;
    }
}
let stack = new Stack(),
    arr = ['鼠', '牛', '虎', '兔', '龙', '蛇', '马', '羊', '猴', '鸡', '狗', '猪'];
arr.forEach(item => {
    stack.push(item);
});
console.log(stack.print()); // 鼠 牛 虎 兔 龙 蛇 马 羊 猴 鸡 狗 猪
console.log(stack.peek()); // 猪
stack.pop().pop().pop().pop();
console.log(stack.print()); // 鼠 牛 虎 兔 龙 蛇 马 羊
console.log(stack.isEmpty()); // false
console.log(stack.size()); // 8
```

⚠️ 注意：我们栈这里的push和pop要和数组方法的push和pop方法区分下。

### 队列

> 此处应该有图片和相关的队列说明

代码走一遍：

```typescript
// 队列
class Queue {
    constructor(){
        this.items = [];
    }
    // 入队操作
    enqueue(element = ''){
        if(!element) return;
        this.items.push(element);
        return this;
    }
    // 出队操作
    dequeue(){
        this.items.shift();
        return this;
    }
    // 查看队前元素或者说即将处理的元素
    front(){
        return this.items[0];
    }
    // 查看队列是否为空
    isEmpty(){
        return this.items.length == 0;
    }
    // 查看队列的长度
    len(){
        return this.items.length;
    }
    // 打印队列数据
    print(){
        return this.items.join(' ');
    }
}

let queue = new Queue(),
    arr = ['鼠', '牛', '虎', '兔', '龙', '蛇', '马', '羊', '猴', '鸡', '狗', '猪'];
arr.forEach(item => {
    queue.enqueue(item);
});
console.log(queue.print()); // 鼠 牛 虎 兔 龙 蛇 马 羊 猴 鸡 狗 猪
console.log(queue.isEmpty()); // false
console.log(queue.len()); // 12
queue.dequeue().dequeue();
console.log(queue.front()); // 虎
console.log(queue.print()); // 虎 兔 龙 蛇 马 羊 猴 鸡 狗 猪
```

### 链表

> 此处应该有相关的图片和说明文字

```typescript
// 链表
class Node {
    constructor(element){
        this.element = element;
        this.next = null;
    }
}

class LinkedList {
    constructor(){
        this.length = 0; // 链表长度
        this.head = new Node('head'); // 表头节点
    }
    /**
     * @method find 查找元素的功能，找不到的情况下直接返回链尾节点
     * @param { String } item 要查找的元素
     * @return { Object } 返回查找到的节点 
     */
    find(item = ''){
        let currNode = this.head;
        while(currNode.element != item && currNode.next){
            currNode = currNode.next;
        }
        return currNode;
    }
    /**
    * @method findPrevious 查找链表指定元素的前一个节点
    * @param { String } item 指定的元素
    * @return { Object } 返回查找到的之前元素的前一个节点，找不到节点的话返回链尾节点
    */
    findPrevious(item){
        let currNode = this.head;
        while((currNode.next != null) && (currNode.next.element != item)){
            currNode = currNode.next;
        }
        return currNode;
    }
    /**
     * @method insert 插入功能
     * @param { String } newElement 要出入的元素
     * @param { String } item 想要追加在后的元素（此元素不一定存在）
     */
    insert(newElement = '', item){
        if(!newElement) return;
        let newNode = new Node(newElement),
            currNode = this.find(item);
        newNode.next = currNode.next;
        currNode.next = newNode;
        this.length++;
        return this;
    }
    // 展示链表元素
    display(){
        let currNode = this.head,
            arr = [];
        while(currNode.next != null){
            arr.push(currNode.next.element);
            currNode = currNode.next;
        }
        return arr.join(' ');
    }
    // 链表的长度
    size(){
        return this.length;
    }
    // 查看链表是否为空
    isEmpty(){
        return this.length == 0;
    }
    /**
     * @method indexOf 查看链表中元素的索引
     * @param { String } element 要查找的元素
     */
    indexOf(element){
        let currNode = this.head,
            index = 0;
        while(currNode.next != null){
            index++;
            if(currNode.next.element == element){
                return index;
            }
            currNode = currNode.next;
        }
        return -1;
    }
    /**
     * @method removeEl 移除指定的元素
     * @param { String } element 
     */
    removeEl(element){
        let preNode = this.findPrevious(element);
        preNode.next = preNode.next != null ? preNode.next.next : null;
    }
}

let linkedlist = new LinkedList();
console.log(linkedlist.isEmpty()); // true
linkedlist.insert('鼠').insert('虎').insert('牛', '鼠');
console.log(linkedlist.display()); // 鼠 牛 虎
console.log(linkedlist.find('猪')); // Node { element: '虎', next: null }
console.log(linkedlist.find('鼠')); // Node { element: '鼠', next: Node { element: '牛', next: Node { element: '虎', next: null } } }
console.log(linkedlist.size()); // 3
console.log(linkedlist.indexOf('鼠')); // 1
console.log(linkedlist.indexOf('猪')); // -1
console.log(linkedlist.findPrevious('虎')); // Node { element: '牛', next: Node { element: '虎', next: null } }
linkedlist.removeEl('鼠');
console.log(linkedlist.display()); // 牛 虎
```

### 字典

> 有待补充...


## 数据结构和算法系列（上）

这个系列文章分为上下两章，使用的是javascript语言进行辅助，毕竟自己是前端切图仔。第一章讲的是基本的数据结构--对相关的数据项进行组织的特殊架构。

讲到数据结构，我们都会谈到线性结构和非线性结构。

**1.线性结构**是一个有序数据元素的集合。它应该满足下面的特征：

- 集合中必存在唯一的一个“第一个元素”
- 集合中必存在唯一的一个“最后的元素”
- 除最后一元素之外，其它数据元素均有唯一的“后继”
- 除第一个元素之外，其它数据元素均有唯一的“前驱”

按照百度百科的定义，我们知道符合条件的数据结构就有栈、队列和其它。

**2.非线性结构**其逻辑特征是一个节点元素可以有很多个直接前驱和多个直接后继。

那么，符合条件的数据结构就有图、树和其它。

嗯～了解一下就行。我们进入正题：

### 数组

以十二生肖（鼠、牛、虎、兔、龙、蛇、马、羊、猴、鸡、狗、猪）排序为例：

![array_demo](https://img-fe.ggwan.com/images/d8779522d31c6d-2164x194.png)

我们创建一个数组并打印出结果就一目了然了：

```javascript
let arr = ['鼠', '牛', '虎', '兔', '龙', '蛇', '马', '羊', '猴', '鸡', '狗', '猪'];
arr.forEach((item, index) => {
	console.log(`[ ${index} ] => ${item}`);
});

# [ 0 ] => 鼠
# [ 1 ] => 牛
# [ 2 ] => 虎
# [ 3 ] => 兔
# [ 4 ] => 龙
# [ 5 ] => 蛇
# [ 6 ] => 马
# [ 7 ] => 羊
# [ 8 ] => 猴
# [ 9 ] => 鸡
# [ 10 ] => 狗
# [ 11 ] => 猪
```

**常用的属性**

- length : 表示数组的长度

**常用的方法**

- splice(index, howmany, item, ... itemx)

	**splice()**方法是数组中最强大的方法。可以实现数组元素的添加、删除和替换。`index`参数为整数且必需，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置；`howmany`参数为必需，要删除的项目数量，如果设置为 0，则不会删除项目；`item1, ... itemx`为可选，向数组添加新的项目。
	
- indexOf(searchValue, fromIndex)

	**indexOf()**方法返回某个指定字符串值在数组中的位置。`searchValue`是查询的字符串；`fromIndex`是查询的开始位置，默认是0。如果查询不到，会返回-1。
	
- concat(array1, ... arrayn)

	**concat()**方法用于连接两个或者多个数组。
	
- push(newElement1, ... newElementN)

	**push()**方法可向`数组的末尾`添加一个或者多个元素。
	
- unshift(newElement1, ... newElementN)

	**unshift()**方法可向`数组的开头`添加一个或者多个元素。
	
- pop()

	**pop()**方法用于删除并返回`数组的最后一个元素`。
	
- shift()

	**shift()**方法可以删除数组的`第一个元素`。
	
- reverse()

	**reverse()**方法用于数组的反转
	
- sort(sortFn)

	**sort()**方法是对数组的元素排序。参数`sortFn`可选，其规定排序顺序，必须是函数。
	
```javascript
let values = [0, 1, 5, 10, 15];
values.sort();
console.log(values); // [0, 1, 10, 15, 5]
// 为什么会出现这种排序结果呢❓
// 因为在忽略sortFn的情况下，元素会按照转换为的字符串的各个字符的Unicode位点进行排序如下
let equalValues = ['0', '1', '5', '10', '15'];
equalValues.sort();
console.log(equalValues); //  ["0", "1", "10", "15", "5"]

let arr = [0, 10, 5, 1, 15];
function compare(el1, el2){
    return el1 - el2; // 升序排列
}
arr.sort(compare);
console.log(arr); // [0, 1, 5, 10, 15]

arr.sort((el1, el2) => {
    return el2 - el1; // 降序排列
}); 
console.log(arr); // [15, 10, 5, 1, 0]
```

- forEach(fn(currentValue, index, arr), thisValue)

	**forEach()**方法用于调用数组的每个元素，并将元素传递给回调函数。参数`function(currentValue, index, arr){}`是一个回调函数。`thisValue`可选，传递给函数的值一般用 "this" 值，如果这个参数为空， "undefined" 会传递给 "this" 值。

- every(fn(currentValue, index, arr), thisValue)

	**every()**方法用于检测数组中所有元素是否符合指定条件，如果数组中检测到有一个元素不满足，则整个表达式返回`false`，且剩余的元素不再检查。如果所有的元素都满足条件，则返回`true`。
	
- some(fn(currentValue,index,arr),thisValue)

	**some()**方法用于检测数组中元素是否满足指定条件。只有有一个符合就返回`true`，剩余的元素不再检查。如果所有元素都不符合条件，则返回`false`。
	
- reduce(fn(accumulator, currentValue, currentIndex, arr), initialValue)

	**reduce()**方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终为一个值。回调函数的四个参数的意义如下：`accumulator`，必需，累计器累计回调的返回值, 它是上一次调用回调时返回的累积值，或initialValue；`currentValue`，必需，数组中正在处理的元素；`currentIndex`,可选,数组中正在处理的当前元素的索引，如果提供了initialValue，则起始索引号为0，否则为1;`arr`,可选,当前元素所属的数组对象。`initialValue`，可选，传递给函数的初始值。
	
```javascript
let arr = [1, 2, 3, 4];
let reducer = (accumulator, currentValue) => accumulator + currentValue;

// 1 + 2 + 3 + 4
console.log(arr.reduce(reducer)); // 10

// 5 + 1 + 2 + 3 + 4
console.log(arr.reduce(reducer, 5)); // 15
```



## 数据结构和算法系列（上）

这个系列文章分为上下两章，使用的是javascript语言进行辅助，毕竟自己是前端切图仔。第一章讲的是基本的数据结构--对相关的数据项进行组织的特殊架构。

讲到数据结构，我们都会谈到线性结构和非线性结构。

**1.线性结构**是一个有序数据元素的集合。它应该满足下面的特征：

- 集合中必存在唯一的一个“第一个元素”
- 集合中必存在唯一的一个“最后的元素”
- 除最后一元素之外，其它数据元素均有唯一的“后继”
- 除第一个元素之外，其它数据元素均有唯一的“前驱”

按照百度百科的定义，我们知道符合条件的数据结构就有栈、队列和其它。

**2.非线性结构**其逻辑特征是一个节点元素可以有很多个直接前驱和多个直接后继。

那么，符合条件的数据结构就有图、树和其它。

嗯～了解一下就行。我们进入正题：

### 数组

数组是一种线性结构，以十二生肖（鼠、牛、虎、兔、龙、蛇、马、羊、猴、鸡、狗、猪）排序为例：

![array_demo](https://img-fe.ggwan.com/images/d8779522d31c6d-2164x194.png)

我们创建一个数组并打印出结果就一目了然了：

```javascript
let arr = ['鼠', '牛', '虎', '兔', '龙', '蛇', '马', '羊', '猴', '鸡', '狗', '猪'];
arr.forEach((item, index) => {
	console.log(`[ ${index} ] => ${item}`);
});

# [ 0 ] => 鼠
# [ 1 ] => 牛
# [ 2 ] => 虎
# [ 3 ] => 兔
# [ 4 ] => 龙
# [ 5 ] => 蛇
# [ 6 ] => 马
# [ 7 ] => 羊
# [ 8 ] => 猴
# [ 9 ] => 鸡
# [ 10 ] => 狗
# [ 11 ] => 猪
```

我们可以在数组的任意位置插入和删除数据，常用的属性和一些方法如下，直接调用相关的方法就可以实现。这里不做演示～

**常用的属性**

- length : 表示数组的长度

**常用的方法**

- splice(index, howmany, item, ... itemx)

	**splice()**方法是数组中最强大的方法。可以实现数组元素的添加、删除和替换。`index`参数为整数且必需，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置；`howmany`参数为必需，要删除的项目数量，如果设置为 0，则不会删除项目；`item1, ... itemx`为可选，向数组添加新的项目。
	
- indexOf(searchValue, fromIndex)

	**indexOf()**方法返回某个指定字符串值在数组中的位置。`searchValue`是查询的字符串；`fromIndex`是查询的开始位置，默认是0。如果查询不到，会返回-1。
	
- concat(array1, ... arrayn)

	**concat()**方法用于连接两个或者多个数组。
	
- push(newElement1, ... newElementN)

	**push()**方法可向`数组的末尾`添加一个或者多个元素。
	
- unshift(newElement1, ... newElementN)

	**unshift()**方法可向`数组的开头`添加一个或者多个元素。
	
- pop()

	**pop()**方法用于删除并返回`数组的最后一个元素`。
	
- shift()

	**shift()**方法可以删除数组的`第一个元素`。
	
- reverse()

	**reverse()**方法用于数组的反转
	
- sort(sortFn)

	**sort()**方法是对数组的元素排序。参数`sortFn`可选，其规定排序顺序，必须是函数。
	
```javascript
let values = [0, 1, 5, 10, 15];
values.sort();
console.log(values); // [0, 1, 10, 15, 5]
// 为什么会出现这种排序结果呢❓
// 因为在忽略sortFn的情况下，元素会按照转换为的字符串的各个字符的Unicode位点进行排序如下
let equalValues = ['0', '1', '5', '10', '15'];
equalValues.sort();
console.log(equalValues); //  ["0", "1", "10", "15", "5"]

let arr = [0, 10, 5, 1, 15];
function compare(el1, el2){
    return el1 - el2; // 升序排列
}
arr.sort(compare);
console.log(arr); // [0, 1, 5, 10, 15]

arr.sort((el1, el2) => {
    return el2 - el1; // 降序排列
}); 
console.log(arr); // [15, 10, 5, 1, 0]
```

- forEach(fn(currentValue, index, arr), thisValue)

	**forEach()**方法用于调用数组的每个元素，并将元素传递给回调函数。参数`function(currentValue, index, arr){}`是一个回调函数。`thisValue`可选，传递给函数的值一般用 "this" 值，如果这个参数为空， "undefined" 会传递给 "this" 值。

- every(fn(currentValue, index, arr), thisValue)

	**every()**方法用于检测数组中所有元素是否符合指定条件，如果数组中检测到有一个元素不满足，则整个表达式返回`false`，且剩余的元素不再检查。如果所有的元素都满足条件，则返回`true`。
	
- some(fn(currentValue,index,arr),thisValue)

	**some()**方法用于检测数组中元素是否满足指定条件。只有有一个符合就返回`true`，剩余的元素不再检查。如果所有元素都不符合条件，则返回`false`。
	
- reduce(fn(accumulator, currentValue, currentIndex, arr), initialValue)

	**reduce()**方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终为一个值。回调函数的四个参数的意义如下：`accumulator`，必需，累计器累计回调的返回值, 它是上一次调用回调时返回的累积值，或initialValue；`currentValue`，必需，数组中正在处理的元素；`currentIndex`,可选,数组中正在处理的当前元素的索引，如果提供了initialValue，则起始索引号为0，否则为1;`arr`,可选,当前元素所属的数组对象。`initialValue`，可选，传递给函数的初始值。
	
```javascript
let arr = [1, 2, 3, 4];
let reducer = (accumulator, currentValue) => accumulator + currentValue;

// 1 + 2 + 3 + 4
console.log(arr.reduce(reducer)); // 10

// 5 + 1 + 2 + 3 + 4
console.log(arr.reduce(reducer, 5)); // 15
```

### 栈

**栈**是一种后进先出(LIFO)线性表，是一种基于数组的数据结构。（ps：其实后面讲到数据结构的或多或少和数组有些影子）

- LIFO(last in first out)表示后进入的元素，第一个弹出栈空间。类似于自动餐托盘，最后放上去的托盘，往往先被拿出来使用。
- 仅允许在表的一端进行插入和移除元素。这一端被称为**栈顶**，相对地，把另一端称为**栈底**。如下图的标识。
- 向一个栈插入新元素称作**进栈、入栈或压栈**，它是将新元素放在栈顶元素上面，使之成为新的栈顶元素。
- 从一个栈删除元素又称为**出栈或退栈**，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。

![stack_demo](https://img-fe.ggwan.com/images/e43e77fe798358-2136x706.png)

我们实际上写一下，熟悉一下栈：

```typescript
class Stack {
    constructor(){
        this.items = [];
    }
    // 入栈操作
    push(element = ''){
        if(!element) return;
        this.items.push(element);
        return this;
    }
    // 出栈操作
    pop(){
        this.items.pop();
        return this;
    }
    // 对栈一瞥，理论上只能看到栈顶或者说即将处理的元素
    peek(){
        return this.items[this.size() - 1];
    }
    // 打印栈数据
    print(){
        return this.items.join(' ');
    }
    // 栈是否为空
    isEmpty(){
        return this.items.length == 0;
    }
    // 返回栈的元素个数
    size(){
        return this.items.length;
    }
}
let stack = new Stack(),
    arr = ['鼠', '牛', '虎', '兔', '龙', '蛇', '马', '羊', '猴', '鸡', '狗', '猪'];
arr.forEach(item => {
    stack.push(item);
});
console.log(stack.print()); // 鼠 牛 虎 兔 龙 蛇 马 羊 猴 鸡 狗 猪
console.log(stack.peek()); // 猪
stack.pop().pop().pop().pop();
console.log(stack.print()); // 鼠 牛 虎 兔 龙 蛇 马 羊
console.log(stack.isEmpty()); // false
console.log(stack.size()); // 8
```

⚠️ 注意：我们栈这里的push和pop要和数组方法的push和pop方法区分下。

说到**栈**，这也让我想到了翻译的一篇文章[JS的执行上下文和环境栈是什么?](https://juejin.im/post/5c855410e51d45555e2626fd)，感兴趣的话可以戳进去看下。

### 队列

**队列**是一种先进先出（FIFO）的受限的线性表。受限体现在允许在表的前端（front）进行操作删除，在表的末尾（rear）进行插入【优先队列这些排除在外】。

![queue_demo](https://img-fe.ggwan.com/images/4c2fafc15894d8-1618x498.png)

代码走一遍：

```typescript
// 队列
class Queue {
    constructor(){
        this.items = [];
    }
    // 入队操作
    enqueue(element = ''){
        if(!element) return;
        this.items.push(element);
        return this;
    }
    // 出队操作
    dequeue(){
        this.items.shift();
        return this;
    }
    // 查看队前元素或者说即将处理的元素
    front(){
        return this.items[0];
    }
    // 查看队列是否为空
    isEmpty(){
        return this.items.length == 0;
    }
    // 查看队列的长度
    len(){
        return this.items.length;
    }
    // 打印队列数据
    print(){
        return this.items.join(' ');
    }
}

let queue = new Queue(),
    arr = ['鼠', '牛', '虎', '兔', '龙', '蛇', '马', '羊', '猴', '鸡', '狗', '猪'];
arr.forEach(item => {
    queue.enqueue(item);
});
console.log(queue.print()); // 鼠 牛 虎 兔 龙 蛇 马 羊 猴 鸡 狗 猪
console.log(queue.isEmpty()); // false
console.log(queue.len()); // 12
queue.dequeue().dequeue();
console.log(queue.front()); // 虎
console.log(queue.print()); // 虎 兔 龙 蛇 马 羊 猴 鸡 狗 猪
```

### 链表

在进入正题之前，我们先来聊聊数组的优缺点。

**优点：**

- 要存储多个元素，比较常用
- 访问便捷，使用[index]即可

**缺点：**

- 数组的创建通常需要申请一段连续的内存空间，并且大小是固定的（大多数的编程语言数组都是固定的），所以在进行扩容的时候难以掌控。（一般情况下，申请一个更大的数组，会是之前的倍数，比如两倍。然后，再将原数组中的元素复制过去）
- 插入数据越是靠前，其成本很高，因为需要进行大量元素的位移。

相对数组，链表亦可以存储多个元素，而且存储的元素在内容中不必是连续的空间；在插入和删除数据时，[时间复杂度](https://github.com/reng99/blogs/issues/5)可以达到O(1)。在查找的元素的时候，还是需要从头开始遍历的，比数组在知道下表的情况下要快，但是数组如果不确定下标的话，那就另说了...

![train](https://img-fe.ggwan.com/images/4fab9eb1353414-1024x295.png)

上面的火车图已经很形象的表示了普通链表的结构，我们再来形象化一下：

> 图片有待补充...(在number上完善)

**链表**是由一组节点组成的集合。每个节点都使用一个对象的引用指向它的后继。如上图。下面用代码实现下：


```typescript
// 链表
class Node {
    constructor(element){
        this.element = element;
        this.next = null;
    }
}

class LinkedList {
    constructor(){
        this.length = 0; // 链表长度
        this.head = new Node('head'); // 表头节点
    }
    /**
     * @method find 查找元素的功能，找不到的情况下直接返回链尾节点
     * @param { String } item 要查找的元素
     * @return { Object } 返回查找到的节点 
     */
    find(item = ''){
        let currNode = this.head;
        while(currNode.element != item && currNode.next){
            currNode = currNode.next;
        }
        return currNode;
    }
    /**
    * @method findPrevious 查找链表指定元素的前一个节点
    * @param { String } item 指定的元素
    * @return { Object } 返回查找到的之前元素的前一个节点，找不到节点的话返回链尾节点
    */
    findPrevious(item){
        let currNode = this.head;
        while((currNode.next != null) && (currNode.next.element != item)){
            currNode = currNode.next;
        }
        return currNode;
    }
    /**
     * @method insert 插入功能
     * @param { String } newElement 要出入的元素
     * @param { String } item 想要追加在后的元素（此元素不一定存在）
     */
    insert(newElement = '', item){
        if(!newElement) return;
        let newNode = new Node(newElement),
            currNode = this.find(item);
        newNode.next = currNode.next;
        currNode.next = newNode;
        this.length++;
        return this;
    }
    // 展示链表元素
    display(){
        let currNode = this.head,
            arr = [];
        while(currNode.next != null){
            arr.push(currNode.next.element);
            currNode = currNode.next;
        }
        return arr.join(' ');
    }
    // 链表的长度
    size(){
        return this.length;
    }
    // 查看链表是否为空
    isEmpty(){
        return this.length == 0;
    }
    /**
     * @method indexOf 查看链表中元素的索引
     * @param { String } element 要查找的元素
     */
    indexOf(element){
        let currNode = this.head,
            index = 0;
        while(currNode.next != null){
            index++;
            if(currNode.next.element == element){
                return index;
            }
            currNode = currNode.next;
        }
        return -1;
    }
    /**
     * @method removeEl 移除指定的元素
     * @param { String } element 
     */
    removeEl(element){
        let preNode = this.findPrevious(element);
        preNode.next = preNode.next != null ? preNode.next.next : null;
    }
}

let linkedlist = new LinkedList();
console.log(linkedlist.isEmpty()); // true
linkedlist.insert('鼠').insert('虎').insert('牛', '鼠');
console.log(linkedlist.display()); // 鼠 牛 虎
console.log(linkedlist.find('猪')); // Node { element: '虎', next: null }
console.log(linkedlist.find('鼠')); // Node { element: '鼠', next: Node { element: '牛', next: Node { element: '虎', next: null } } }
console.log(linkedlist.size()); // 3
console.log(linkedlist.indexOf('鼠')); // 1
console.log(linkedlist.indexOf('猪')); // -1
console.log(linkedlist.findPrevious('虎')); // Node { element: '牛', next: Node { element: '虎', next: null } }
linkedlist.removeEl('鼠');
console.log(linkedlist.display()); // 牛 虎
```

### 字典

> 此处应该有详细的文字说明并配上图片

```typescript
class Dictionary {
    constructor(){
        this.items = {};
    }
    /**
     * @method set 设置字典的键值对
     * @param { String } key 键
     * @param {*} value 值
     */
    set(key = '', value = ''){
        this.items[key] = value;
        return this;
    }
    /**
     * @method get 获取某个值
     * @param { String } key 键
     */
    get(key = ''){
        return this.has(key) ? this.items[key] : undefined;
    }
    /**
     * @method has 判断是否含有某个键的值
     * @param { String } key 键
     */
    has(key = ''){
        return this.items.hasOwnProperty(key);
    }
    /**
     * @method remove 移除元素
     * @param { String } key 
     */
    remove(key){
        if(!this.has(key))  return false;
        delete this.items[key];
        return true;
    }
    // 展示字典的键
    keys(){
        return Object.keys(this.items).join(' ');
    }
    // 字典的大小
    size(){
        return Object.keys(this.items).length;
    }
    // 展示字典的值
    values(){
        return Object.values(this.items).join(' ');
    }
    // 清空字典
    clear(){
        this.items = {};
        return this;
    }
}

let dictionary = new Dictionary(),
    arr = ['鼠', '牛', '虎', '兔', '龙', '蛇', '马', '羊', '猴', '鸡', '狗', '猪'];
    arr.forEach((item, index) => {
        dictionary.set('第'+(++index)+'生肖', item);
    });
console.log(dictionary.keys()); // 第1生肖 第2生肖 第3生肖 第4生肖 第5生肖 第6生肖 第7生肖 第8生肖 第9生肖 第10生肖 第11生肖 第12生肖
console.log(dictionary.values()); // 鼠 牛 虎 兔 龙 蛇 马 羊 猴 鸡 狗 猪
console.log(dictionary.has('第5生肖')); // true
console.log(dictionary.get('第3生肖')); // 虎
console.log(dictionary.remove('第12生肖')); // true
console.log(dictionary.size()); // 11
console.log(dictionary.clear().size()); // 0
```

### 集合

> 相关的文字说明和图片啦

es6中已经封装好了可用的[Set类](http://es6.ruanyifeng.com/#docs/set-map)。

```typescript
// 集合
class Set {
    constructor(){
        this.items = [];
    }
    /**
     * @method add 添加元素
     * @param { String } element 
     * @return { Boolean }
     */
    add(element = ''){
        if(this.items.indexOf(element) >= 0) return false;
        this.items.push(element);
        return true;
    }
    // 集合的大小
    size(){
        return this.items.length;
    }
    // 集合是否包含某指定元素
    has(element = ''){
        return this.items.indexOf(element) >= 0;
    }
    // 展示集合
    show(){
        return this.items.join(' ');
    }
    // 移除某个元素
    remove(element){
        let pos = this.items.indexOf(element);
        if(pos < 0) return false;
        this.items.splice(pos, 1);
        return true;
    }
    /**
     * @method union 并集
     * @param { Array } set 数组集合
     * @return { Object } 返回并集的对象
     */
    union(set = []){
        let tempSet = new Set();
        for(let i = 0; i < this.items.length; i++){
            tempSet.add(this.items[i]);
        }
        for(let i = 0; i < set.items.length; i++){
            if(tempSet.has(set.items[i])) continue;
            tempSet.items.push(set.items[i]);
        }
        return tempSet;
    }
    /**
     * @method intersect 交集
     * @param { Array } set 数组集合
     * @return { Object } 返回交集的对象
     */
    intersect(set = []){
        let tempSet = new Set();
        for(let i = 0; i < this.items.length; i++){
            if(set.has(this.items[i])){
                tempSet.add(this.items[i]);
            }
        }
        return tempSet;
    }
    isSubsetOf(set = []){
        if(this.size() > set.size()) return false;
        this.items.forEach*(item => {
            if(!set.has(item)) return false;
        });
        return true;
    }
}

let set = new Set(),
    arr = ['鼠', '牛', '虎', '兔', '龙', '蛇', '马', '羊', '猴'];
arr.forEach(item => {
    set.add(item);
});
console.log(set.show()); // 鼠 牛 虎 兔 龙 蛇 马 羊 猴
console.log(set.has('猪')); // false
console.log(set.size()); // 9
set.remove('鼠');
console.log(set.show()); // 牛 虎 兔 龙 蛇 马 羊 猴
let setAnother = new Set(),
    anotherArr = ['马', '羊', '猴', '鸡', '狗', '猪'];
anotherArr.forEach(item => {
    setAnother.add(item);
});
console.log(set.union(setAnother).show()); // 牛 虎 兔 龙 蛇 马 羊 猴 鸡 狗 猪
console.log(set.intersect(setAnother).show()); // 马 羊 猴
console.log(set.isSubsetOf(setAnother)); // false
```

### 后话

> 文章中的一些案例来自coderwhy的数据结构和算法系列文章，感谢其授权
 
![author_wechat_permission](https://img-fe.ggwan.com/images/a3198fa0bca62f-1272x1008.png)
 
 > 文章首发
 
 > 更多内容 https://github.com/reng99/blogs
 
### 参考

- [coderwhy的数据结构和算法系列文章](https://www.jianshu.com/p/38853c044156)

- 《数据结构与算法JavaScript描述》


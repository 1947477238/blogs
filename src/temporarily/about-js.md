### 简述js

> 下面的内容是javascript的简单概述

```bash
    . ES5
    │
    ├── 浏览器兼容的历史
    │       ├── Netscape 于1995年发布JavaScript
    │       └── 微软于1996年发布JScript
    │
    ├── JavaScript构成
    │       ├── ECMAScript(核心)
    │       ├── DOM(文档对象模型)
    │       └── BOM(浏览器对象模型)
    │
    ├── [当前五大浏览器](https://www.kuyh.com/642.html)
    │       ├── IE
    │       ├── Firefox
    │       ├── Chrome
    │       ├── Safari
    │       └── Opera
    │
    ├── ES5的数据类型
    │       ├── 基本数据类型: Undefined,Null,Boolean,Number和String       
    │       └── 复杂数据类型: Object
    │
    ├── 函数参数传递方式（高3说的是按值传递，个人理解是栈区）
    │       ├── 基本类型（按值传递--栈区）
    │       └── 引用类型（按值传递--栈区，按引用传递--堆区）
    │
    ├── 垃圾收集(自动垃圾收集机制)
    │       ├── 标记清除（离开作用域的值将被自动标记为可回收）
    │       ├── 引用计数（IE9后消除了这种原因导致的内存泄漏问题）
    │       ├── 性能问题（周期性进行垃圾回收）
    │       └── 管理内存（解除引用，为执行中的代码只保留必要的数据）
    │
    ├── [引用类型](https://www.cnblogs.com/guorange/p/6657765.html?utm_source=itdadao&utm_medium=referral)
    │       ├── Object
    │       ├── Array
    │       ├── Date
    │       ├── RegExp
    │       ├── Function
    │       ├── 基本包装类型（是基本类型也是引用类型）所以对应的基本类型值可以当作对象来访问
    │       │       ├── Boolean
    │       │       ├── Number
    │       │       └── String
    │       │
    │       └── 当体内置对象
    │               ├── Global对象
    │               └── Math对象
    │
    │
    ├── 函数length和prototype属性
    │       ├── length（函数希望接收的命名参数的个数）
    │       └── prototype（它是保存引用类型所有实例方法的真正所在）
    │
    ├── [函数中的call()和apply()方法](https://www.cnblogs.com/phoebeyue/p/9216514.html)
    │       ├── call 设置函数体内this的指向。参数传值(obj,arg1,arg2)
    │       └── apply 设置函数体内this的指向。参数传值(obj,[arg1,arg2])
    │
    ├── 对象属性类型（通过Object.defineProperty进行定义）
    │       ├── 数据属性（[[Configurable]],[[Enumerable]],[[Writable]],[[Value]]）
    │       └── 访问器属性（[[Configurable]],[[Enumerable]],[[Get]],[[Set]]）
    │
    ├── 创建对象
    │       ├── 1.工厂模式（解决了创建多个相似对象的问题，没有解决对象识别的问题）
    │       ├── 2.构造函数模式
    │       ├── 3.原型模式（共享属性和方法方式不容易区分私有的属性和方法）
    │       ├── 4.组合使用构造函数模式和原型模式（私有和共有的属性和方法做区分）【常用的模式】
    │       ├── 5.动态原型模式（对第4点的改善，将原型封装到构造函数中，更贴切oo语言的类）【理想的模式】
    │       ├── 6.寄生构造模式（工厂模式+构造函数模式，不建议使用）
    │       └── 7.稳妥构造函数模式（禁用this和new的场景中使用，不建议其他场景使用）
    │
    ├── 继承方式
    │       ├── 1.原型链（不区分私有和共有，不能向超类型的构造函数传递参数）
    │       ├── 2.借用构造函数（解决了向构造函数传参的问题，巧用apply和call方法）
    │       ├── 3.组合继承（整合上面第1和2点的优点）
    │       ├──
    │       ├──
    │       └──
    │
    ├── 创建函数的方式
    │       ├── 函数声明（可以实现函数的提升，意思是在执行代码之前会先读取函数声明）
    │       └── 函数表达式（不可以进行函数的提升）【推荐】
    │
    ├── 递归的使用
    │       ├── 非严格模式下，巧用arguments.callee：一个指向正在执行的函数的指针
    │       └── 严格模式和非严格模式下，使用命名函数表达式实现递归【推荐】
    │
    ├── 闭包（指有权访问另一个函数作用域中的变量的函数）
    │       ├── [闭包的外部作用域是在其定义的时候已决定，而不是执行的时候](https://codepen.io/reng99/pen/KJZogm)
    │       ├── 闭包可以访问其外部（父）作用域中定义的所有变量（即向上查询）
    │       ├── 闭包副作用1：由于闭包会携带包含它的函数的作用域，因此会比其他函数占用更多的内存
    │       └── 闭包副作用2：只能取得包含函数中任何变量的最后一个值
    │
    ├── this对象
    │       ├── 全局函数中，this等于window
    │       ├── 函数作为某个对象的方法调用时，this指向那个对象
    │       └── 特殊：匿名函数的执行环境具有全局性，因此其this对象通常指向window
    │
    ├── 浏览器对象模型(BOM)
    │       ├── window对象
    │       ├── location对象：不仅提供了与当前窗口中加载的文档有关信息，还提供了一些导航功能
    │       ├── navigator对象：是识别客户端浏览器的实际标准
    │       ├── screen对象：表明客户端的能力【用处不大】
    │       └── history对象：保存着用户上网历史记录
    │
    │
    │
    │
    │
    │
    └──
```